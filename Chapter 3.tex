\chapter{Package Development} \label{cpt:Pkg Dev}

\section{Introduction}

\section{Package Structure}

The package consists of 7 R scripts, with their functionalities defined as below:

\begin{table}[ht] \label{tab:pkg_scripts}
\begin{tabular}{p{0.25\linewidth} | p{0.65\linewidth}}
File                           & Contents                                                                 \\ \hline
\mintinline{R}|Option.R|       & Methods creating and updating option and option.env objects              \\
\mintinline{R}|Price.R|        & Pricing functions takes objects input and calls specific pricing engines \\
\mintinline{R}|MonteCarlo.R|   & Monte Carlo option pricing method engine functions                       \\
\mintinline{R}|BlackScholes.R| & Black-Scholes option pricing method engine functions                     \\
\mintinline{R}|Binomial.R|     & Binomial option pricing method engine functions                          \\
\mintinline{R}|Trinomial.R|    & Trinomial option pricing method engine functions                         \\
\mintinline{R}|Tools.R|        & Other supplementary functions used in package                           
\end{tabular}
\caption{Package R Scripts}
\end{table} 

For the simplicity of user access, only three functions are exported, they are:

\begin{table}[ht] \label{tab:pkg_functions}
\begin{tabular}{p{0.25\linewidth} | p{0.65\linewidth}}
Function                            & Description \\ \hline
\mintinline{R}|option()|            & Create new \mintinline{R}|"option"| class object, which encapsulates the characteristics of an option \\
\mintinline{R}|option.env()|        & Create new \mintinline{R}|"env"| class object, which encapsulates the market environment setup \\
\mintinline{R}|price.option()|      & Pricing the option based on specified option, market environment, and method input                       
\end{tabular}
\caption{Package Exported Functions}
\end{table}
\section{Objective Oriented Programming in R}

Existing packages in R ecosystem provides comprehensive pricing algorithms for financial derivatives. However, their function are based on Procedural Oriented Programming (POP). POP functions can be called directly by passing in required arguments. For simple options pricing cases, such as pricing individual options, using POP functions is intuitive. However, many real scenarios require pricing options in a complex formulation, such as compounded options (i.e. options with underlying assets being another option) and combination of options (i.e. spread, straddle, stringle, and other option strategies). In these situations, managing numerous arguments for POP functions can be difficult and inefficient.

The \mintinline{R}|rmcop| package proposed an Objective Oriented Programming (OOP) approach for pricing financial options in R. It encapsulates multiple arguments, such as option style, type, strike price, and maturity time, into an \mintinline{R}|option| class object. It also allows encapsulation of other market environemnt arguments, such as interest rate, dividend yield rate, and volatility measure into an \mintinline{R}|option.env| class object. The OOP structure enables easier variables managements and facilitates the comparison of prices among different sets of options and market environments.

The codes below demonstrates the calculation of an theoretical European vanilla call option with strike price $K = 20$, maturity $t = 0.75$, under the market condition such that the current price is $S = 20$, fixed interest rate is $r = 1\%$, and market volatility measured by $\sigma = 0.1$. We use Monte Carlo (i.e. \mintinline{R}|mc|) method with $n = 100$ replications and number of time steps per replication $steps = 1$.

OOP approach requires extra steps declaring objects before using the function, but once the declaration is completed, calling the pricing funcion is much simpler than the POP approach. As above, it only required two (object) arguments, \mintinline{R}|obj| and \mintinline{R}|env|.

R provides two ways to perform OOP, the S3 and S4 methods. The S3 class objects are based on R \mintinline{R}|list| objects. An R list contains a \mintinline{R}|class| attribute, which can be customised into string (or vector of strings) that can be interpreted as a list's corresponding S3 class (i.e. so that the list itself became an object of that class). Other items within the list can be treated as object's properties under the OOP scope, and can be extracted using the \mintinline{R}|$| operator. Here is an example on how to implement OOP using S3 method in R.

\begin{Rminted}
John <- list(
    "age" = 20,
    "gender" = "male",
    "nation" = "UK"
)
class(John) <- "student"
\end{Rminted}

We first define a new \mintinline{R}|list| object named ``John'', which contains three items (age, gender, and nationality). Then, we redefined the class of this list using the \mintinline{R}|class()| function to ``student''. Now, we have created a new object named ``John'' of the class ``student'' under the S3 scheme.

The S4 methods requires more rigorous class and object definition, as one would typically see in an OOP language such as Python and Java. The development of our pricing functions does not require rigorous OOP structure or defining generic functions, so S3 method is sufficient for its development.

\section{Deterministic Methods}

\subsection{vanilla.bs}

\subsection{vanilla.binomial}

\subsection{vanilla.trinomial}

\section{Monte Carlo Methods}

\subsection{vanilla.mc}

\subsection{asian.mc}

\subsection{barrier.mc}

\subsection{binary.mc}

\subsection{lookback.mc}

\newpage